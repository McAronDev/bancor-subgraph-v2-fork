// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class PriceDataUpdate extends ethereum.Event {
  get params(): PriceDataUpdate__Params {
    return new PriceDataUpdate__Params(this);
  }
}

export class PriceDataUpdate__Params {
  _event: PriceDataUpdate;

  constructor(event: PriceDataUpdate) {
    this._event = event;
  }

  get _connectorToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _tokenSupply(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _connectorBalance(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _connectorWeight(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class LiquidityAdded extends ethereum.Event {
  get params(): LiquidityAdded__Params {
    return new LiquidityAdded__Params(this);
  }
}

export class LiquidityAdded__Params {
  _event: LiquidityAdded;

  constructor(event: LiquidityAdded) {
    this._event = event;
  }

  get _provider(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _reserveToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _newBalance(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get _newSupply(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class LiquidityRemoved extends ethereum.Event {
  get params(): LiquidityRemoved__Params {
    return new LiquidityRemoved__Params(this);
  }
}

export class LiquidityRemoved__Params {
  _event: LiquidityRemoved;

  constructor(event: LiquidityRemoved) {
    this._event = event;
  }

  get _provider(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _reserveToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _newBalance(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get _newSupply(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class Activation extends ethereum.Event {
  get params(): Activation__Params {
    return new Activation__Params(this);
  }
}

export class Activation__Params {
  _event: Activation;

  constructor(event: Activation) {
    this._event = event;
  }

  get _type(): i32 {
    return this._event.parameters[0].value.toI32();
  }

  get _anchor(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _activated(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class Conversion extends ethereum.Event {
  get params(): Conversion__Params {
    return new Conversion__Params(this);
  }
}

export class Conversion__Params {
  _event: Conversion;

  constructor(event: Conversion) {
    this._event = event;
  }

  get _fromToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _toToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _trader(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get _return(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get _conversionFee(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class TokenRateUpdate extends ethereum.Event {
  get params(): TokenRateUpdate__Params {
    return new TokenRateUpdate__Params(this);
  }
}

export class TokenRateUpdate__Params {
  _event: TokenRateUpdate;

  constructor(event: TokenRateUpdate) {
    this._event = event;
  }

  get _token1(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _token2(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _rateN(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _rateD(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class ConversionFeeUpdate extends ethereum.Event {
  get params(): ConversionFeeUpdate__Params {
    return new ConversionFeeUpdate__Params(this);
  }
}

export class ConversionFeeUpdate__Params {
  _event: ConversionFeeUpdate;

  constructor(event: ConversionFeeUpdate) {
    this._event = event;
  }

  get _prevFee(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _newFee(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class OwnerUpdate extends ethereum.Event {
  get params(): OwnerUpdate__Params {
    return new OwnerUpdate__Params(this);
  }
}

export class OwnerUpdate__Params {
  _event: OwnerUpdate;

  constructor(event: OwnerUpdate) {
    this._event = event;
  }

  get _prevOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LiquidityPoolV1Converter__connectorsResult {
  value0: BigInt;
  value1: BigInt;
  value2: boolean;
  value3: boolean;
  value4: boolean;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: boolean,
    value3: boolean,
    value4: boolean
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    map.set("value4", ethereum.Value.fromBoolean(this.value4));
    return map;
  }
}

export class LiquidityPoolV1Converter__getReturnResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class LiquidityPoolV1Converter__targetAmountAndFeeResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class LiquidityPoolV1Converter__reservesResult {
  value0: BigInt;
  value1: BigInt;
  value2: boolean;
  value3: boolean;
  value4: boolean;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: boolean,
    value3: boolean,
    value4: boolean
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    map.set("value4", ethereum.Value.fromBoolean(this.value4));
    return map;
  }
}

export class LiquidityPoolV1Converter extends ethereum.SmartContract {
  static bind(address: Address): LiquidityPoolV1Converter {
    return new LiquidityPoolV1Converter("LiquidityPoolV1Converter", address);
  }

  reserveRatio(): BigInt {
    let result = super.call("reserveRatio", "reserveRatio():(uint32)", []);

    return result[0].toBigInt();
  }

  try_reserveRatio(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("reserveRatio", "reserveRatio():(uint32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  connectors(_address: Address): LiquidityPoolV1Converter__connectorsResult {
    let result = super.call(
      "connectors",
      "connectors(address):(uint256,uint32,bool,bool,bool)",
      [ethereum.Value.fromAddress(_address)]
    );

    return new LiquidityPoolV1Converter__connectorsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBoolean(),
      result[3].toBoolean(),
      result[4].toBoolean()
    );
  }

  try_connectors(
    _address: Address
  ): ethereum.CallResult<LiquidityPoolV1Converter__connectorsResult> {
    let result = super.tryCall(
      "connectors",
      "connectors(address):(uint256,uint32,bool,bool,bool)",
      [ethereum.Value.fromAddress(_address)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LiquidityPoolV1Converter__connectorsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBoolean(),
        value[3].toBoolean(),
        value[4].toBoolean()
      )
    );
  }

  hasETHReserve(): boolean {
    let result = super.call("hasETHReserve", "hasETHReserve():(bool)", []);

    return result[0].toBoolean();
  }

  try_hasETHReserve(): ethereum.CallResult<boolean> {
    let result = super.tryCall("hasETHReserve", "hasETHReserve():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  connectorTokens(_index: BigInt): Address {
    let result = super.call(
      "connectorTokens",
      "connectorTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(_index)]
    );

    return result[0].toAddress();
  }

  try_connectorTokens(_index: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "connectorTokens",
      "connectorTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(_index)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  reserveWeight(_reserveToken: Address): BigInt {
    let result = super.call(
      "reserveWeight",
      "reserveWeight(address):(uint32)",
      [ethereum.Value.fromAddress(_reserveToken)]
    );

    return result[0].toBigInt();
  }

  try_reserveWeight(_reserveToken: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reserveWeight",
      "reserveWeight(address):(uint32)",
      [ethereum.Value.fromAddress(_reserveToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getReturn(
    _sourceToken: Address,
    _targetToken: Address,
    _amount: BigInt
  ): LiquidityPoolV1Converter__getReturnResult {
    let result = super.call(
      "getReturn",
      "getReturn(address,address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_sourceToken),
        ethereum.Value.fromAddress(_targetToken),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );

    return new LiquidityPoolV1Converter__getReturnResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getReturn(
    _sourceToken: Address,
    _targetToken: Address,
    _amount: BigInt
  ): ethereum.CallResult<LiquidityPoolV1Converter__getReturnResult> {
    let result = super.tryCall(
      "getReturn",
      "getReturn(address,address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_sourceToken),
        ethereum.Value.fromAddress(_targetToken),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LiquidityPoolV1Converter__getReturnResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  isActive(): boolean {
    let result = super.call("isActive", "isActive():(bool)", []);

    return result[0].toBoolean();
  }

  try_isActive(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isActive", "isActive():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  onlyOwnerCanUpdateRegistry(): boolean {
    let result = super.call(
      "onlyOwnerCanUpdateRegistry",
      "onlyOwnerCanUpdateRegistry():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_onlyOwnerCanUpdateRegistry(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "onlyOwnerCanUpdateRegistry",
      "onlyOwnerCanUpdateRegistry():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  converterType(): i32 {
    let result = super.call("converterType", "converterType():(uint16)", []);

    return result[0].toI32();
  }

  try_converterType(): ethereum.CallResult<i32> {
    let result = super.tryCall("converterType", "converterType():(uint16)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  version(): i32 {
    let result = super.call("version", "version():(uint16)", []);

    return result[0].toI32();
  }

  try_version(): ethereum.CallResult<i32> {
    let result = super.tryCall("version", "version():(uint16)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  conversionFee(): BigInt {
    let result = super.call("conversionFee", "conversionFee():(uint32)", []);

    return result[0].toBigInt();
  }

  try_conversionFee(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("conversionFee", "conversionFee():(uint32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  prevRegistry(): Address {
    let result = super.call("prevRegistry", "prevRegistry():(address)", []);

    return result[0].toAddress();
  }

  try_prevRegistry(): ethereum.CallResult<Address> {
    let result = super.tryCall("prevRegistry", "prevRegistry():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  decimalLength(_x: BigInt): BigInt {
    let result = super.call(
      "decimalLength",
      "decimalLength(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_x)]
    );

    return result[0].toBigInt();
  }

  try_decimalLength(_x: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "decimalLength",
      "decimalLength(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_x)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  connectorTokenCount(): i32 {
    let result = super.call(
      "connectorTokenCount",
      "connectorTokenCount():(uint16)",
      []
    );

    return result[0].toI32();
  }

  try_connectorTokenCount(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "connectorTokenCount",
      "connectorTokenCount():(uint16)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  registry(): Address {
    let result = super.call("registry", "registry():(address)", []);

    return result[0].toAddress();
  }

  try_registry(): ethereum.CallResult<Address> {
    let result = super.tryCall("registry", "registry():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  maxConversionFee(): BigInt {
    let result = super.call(
      "maxConversionFee",
      "maxConversionFee():(uint32)",
      []
    );

    return result[0].toBigInt();
  }

  try_maxConversionFee(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maxConversionFee",
      "maxConversionFee():(uint32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  reserveTokenCount(): i32 {
    let result = super.call(
      "reserveTokenCount",
      "reserveTokenCount():(uint16)",
      []
    );

    return result[0].toI32();
  }

  try_reserveTokenCount(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "reserveTokenCount",
      "reserveTokenCount():(uint16)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  geometricMean(_values: Array<BigInt>): BigInt {
    let result = super.call(
      "geometricMean",
      "geometricMean(uint256[]):(uint256)",
      [ethereum.Value.fromUnsignedBigIntArray(_values)]
    );

    return result[0].toBigInt();
  }

  try_geometricMean(_values: Array<BigInt>): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "geometricMean",
      "geometricMean(uint256[]):(uint256)",
      [ethereum.Value.fromUnsignedBigIntArray(_values)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  targetAmountAndFee(
    _sourceToken: Address,
    _targetToken: Address,
    _amount: BigInt
  ): LiquidityPoolV1Converter__targetAmountAndFeeResult {
    let result = super.call(
      "targetAmountAndFee",
      "targetAmountAndFee(address,address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_sourceToken),
        ethereum.Value.fromAddress(_targetToken),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );

    return new LiquidityPoolV1Converter__targetAmountAndFeeResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_targetAmountAndFee(
    _sourceToken: Address,
    _targetToken: Address,
    _amount: BigInt
  ): ethereum.CallResult<LiquidityPoolV1Converter__targetAmountAndFeeResult> {
    let result = super.tryCall(
      "targetAmountAndFee",
      "targetAmountAndFee(address,address,uint256):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(_sourceToken),
        ethereum.Value.fromAddress(_targetToken),
        ethereum.Value.fromUnsignedBigInt(_amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LiquidityPoolV1Converter__targetAmountAndFeeResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  roundDiv(_n: BigInt, _d: BigInt): BigInt {
    let result = super.call("roundDiv", "roundDiv(uint256,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(_n),
      ethereum.Value.fromUnsignedBigInt(_d)
    ]);

    return result[0].toBigInt();
  }

  try_roundDiv(_n: BigInt, _d: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "roundDiv",
      "roundDiv(uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_n),
        ethereum.Value.fromUnsignedBigInt(_d)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  conversionsEnabled(): boolean {
    let result = super.call(
      "conversionsEnabled",
      "conversionsEnabled():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_conversionsEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "conversionsEnabled",
      "conversionsEnabled():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  conversionWhitelist(): Address {
    let result = super.call(
      "conversionWhitelist",
      "conversionWhitelist():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_conversionWhitelist(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "conversionWhitelist",
      "conversionWhitelist():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  reserveTokens(param0: BigInt): Address {
    let result = super.call(
      "reserveTokens",
      "reserveTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toAddress();
  }

  try_reserveTokens(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "reserveTokens",
      "reserveTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isV28OrHigher(): boolean {
    let result = super.call("isV28OrHigher", "isV28OrHigher():(bool)", []);

    return result[0].toBoolean();
  }

  try_isV28OrHigher(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isV28OrHigher", "isV28OrHigher():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  anchor(): Address {
    let result = super.call("anchor", "anchor():(address)", []);

    return result[0].toAddress();
  }

  try_anchor(): ethereum.CallResult<Address> {
    let result = super.tryCall("anchor", "anchor():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  newOwner(): Address {
    let result = super.call("newOwner", "newOwner():(address)", []);

    return result[0].toAddress();
  }

  try_newOwner(): ethereum.CallResult<Address> {
    let result = super.tryCall("newOwner", "newOwner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  reserves(param0: Address): LiquidityPoolV1Converter__reservesResult {
    let result = super.call(
      "reserves",
      "reserves(address):(uint256,uint32,bool,bool,bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new LiquidityPoolV1Converter__reservesResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBoolean(),
      result[3].toBoolean(),
      result[4].toBoolean()
    );
  }

  try_reserves(
    param0: Address
  ): ethereum.CallResult<LiquidityPoolV1Converter__reservesResult> {
    let result = super.tryCall(
      "reserves",
      "reserves(address):(uint256,uint32,bool,bool,bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LiquidityPoolV1Converter__reservesResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBoolean(),
        value[3].toBoolean(),
        value[4].toBoolean()
      )
    );
  }

  getConnectorBalance(_connectorToken: Address): BigInt {
    let result = super.call(
      "getConnectorBalance",
      "getConnectorBalance(address):(uint256)",
      [ethereum.Value.fromAddress(_connectorToken)]
    );

    return result[0].toBigInt();
  }

  try_getConnectorBalance(
    _connectorToken: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getConnectorBalance",
      "getConnectorBalance(address):(uint256)",
      [ethereum.Value.fromAddress(_connectorToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  reserveBalance(_reserveToken: Address): BigInt {
    let result = super.call(
      "reserveBalance",
      "reserveBalance(address):(uint256)",
      [ethereum.Value.fromAddress(_reserveToken)]
    );

    return result[0].toBigInt();
  }

  try_reserveBalance(_reserveToken: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reserveBalance",
      "reserveBalance(address):(uint256)",
      [ethereum.Value.fromAddress(_reserveToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  token(): Address {
    let result = super.call("token", "token():(address)", []);

    return result[0].toAddress();
  }

  try_token(): ethereum.CallResult<Address> {
    let result = super.tryCall("token", "token():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class RestrictRegistryUpdateCall extends ethereum.Call {
  get inputs(): RestrictRegistryUpdateCall__Inputs {
    return new RestrictRegistryUpdateCall__Inputs(this);
  }

  get outputs(): RestrictRegistryUpdateCall__Outputs {
    return new RestrictRegistryUpdateCall__Outputs(this);
  }
}

export class RestrictRegistryUpdateCall__Inputs {
  _call: RestrictRegistryUpdateCall;

  constructor(call: RestrictRegistryUpdateCall) {
    this._call = call;
  }

  get _onlyOwnerCanUpdateRegistry(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class RestrictRegistryUpdateCall__Outputs {
  _call: RestrictRegistryUpdateCall;

  constructor(call: RestrictRegistryUpdateCall) {
    this._call = call;
  }
}

export class TransferTokenOwnershipCall extends ethereum.Call {
  get inputs(): TransferTokenOwnershipCall__Inputs {
    return new TransferTokenOwnershipCall__Inputs(this);
  }

  get outputs(): TransferTokenOwnershipCall__Outputs {
    return new TransferTokenOwnershipCall__Outputs(this);
  }
}

export class TransferTokenOwnershipCall__Inputs {
  _call: TransferTokenOwnershipCall;

  constructor(call: TransferTokenOwnershipCall) {
    this._call = call;
  }

  get _newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferTokenOwnershipCall__Outputs {
  _call: TransferTokenOwnershipCall;

  constructor(call: TransferTokenOwnershipCall) {
    this._call = call;
  }
}

export class AcceptTokenOwnershipCall extends ethereum.Call {
  get inputs(): AcceptTokenOwnershipCall__Inputs {
    return new AcceptTokenOwnershipCall__Inputs(this);
  }

  get outputs(): AcceptTokenOwnershipCall__Outputs {
    return new AcceptTokenOwnershipCall__Outputs(this);
  }
}

export class AcceptTokenOwnershipCall__Inputs {
  _call: AcceptTokenOwnershipCall;

  constructor(call: AcceptTokenOwnershipCall) {
    this._call = call;
  }
}

export class AcceptTokenOwnershipCall__Outputs {
  _call: AcceptTokenOwnershipCall;

  constructor(call: AcceptTokenOwnershipCall) {
    this._call = call;
  }
}

export class WithdrawFromAnchorCall extends ethereum.Call {
  get inputs(): WithdrawFromAnchorCall__Inputs {
    return new WithdrawFromAnchorCall__Inputs(this);
  }

  get outputs(): WithdrawFromAnchorCall__Outputs {
    return new WithdrawFromAnchorCall__Outputs(this);
  }
}

export class WithdrawFromAnchorCall__Inputs {
  _call: WithdrawFromAnchorCall;

  constructor(call: WithdrawFromAnchorCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class WithdrawFromAnchorCall__Outputs {
  _call: WithdrawFromAnchorCall;

  constructor(call: WithdrawFromAnchorCall) {
    this._call = call;
  }
}

export class LiquidateCall extends ethereum.Call {
  get inputs(): LiquidateCall__Inputs {
    return new LiquidateCall__Inputs(this);
  }

  get outputs(): LiquidateCall__Outputs {
    return new LiquidateCall__Outputs(this);
  }
}

export class LiquidateCall__Inputs {
  _call: LiquidateCall;

  constructor(call: LiquidateCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class LiquidateCall__Outputs {
  _call: LiquidateCall;

  constructor(call: LiquidateCall) {
    this._call = call;
  }
}

export class UpdateRegistryCall extends ethereum.Call {
  get inputs(): UpdateRegistryCall__Inputs {
    return new UpdateRegistryCall__Inputs(this);
  }

  get outputs(): UpdateRegistryCall__Outputs {
    return new UpdateRegistryCall__Outputs(this);
  }
}

export class UpdateRegistryCall__Inputs {
  _call: UpdateRegistryCall;

  constructor(call: UpdateRegistryCall) {
    this._call = call;
  }
}

export class UpdateRegistryCall__Outputs {
  _call: UpdateRegistryCall;

  constructor(call: UpdateRegistryCall) {
    this._call = call;
  }
}

export class SetConversionWhitelistCall extends ethereum.Call {
  get inputs(): SetConversionWhitelistCall__Inputs {
    return new SetConversionWhitelistCall__Inputs(this);
  }

  get outputs(): SetConversionWhitelistCall__Outputs {
    return new SetConversionWhitelistCall__Outputs(this);
  }
}

export class SetConversionWhitelistCall__Inputs {
  _call: SetConversionWhitelistCall;

  constructor(call: SetConversionWhitelistCall) {
    this._call = call;
  }

  get _whitelist(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetConversionWhitelistCall__Outputs {
  _call: SetConversionWhitelistCall;

  constructor(call: SetConversionWhitelistCall) {
    this._call = call;
  }
}

export class WithdrawTokensCall extends ethereum.Call {
  get inputs(): WithdrawTokensCall__Inputs {
    return new WithdrawTokensCall__Inputs(this);
  }

  get outputs(): WithdrawTokensCall__Outputs {
    return new WithdrawTokensCall__Outputs(this);
  }
}

export class WithdrawTokensCall__Inputs {
  _call: WithdrawTokensCall;

  constructor(call: WithdrawTokensCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class WithdrawTokensCall__Outputs {
  _call: WithdrawTokensCall;

  constructor(call: WithdrawTokensCall) {
    this._call = call;
  }
}

export class TransferAnchorOwnershipCall extends ethereum.Call {
  get inputs(): TransferAnchorOwnershipCall__Inputs {
    return new TransferAnchorOwnershipCall__Inputs(this);
  }

  get outputs(): TransferAnchorOwnershipCall__Outputs {
    return new TransferAnchorOwnershipCall__Outputs(this);
  }
}

export class TransferAnchorOwnershipCall__Inputs {
  _call: TransferAnchorOwnershipCall;

  constructor(call: TransferAnchorOwnershipCall) {
    this._call = call;
  }

  get _newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferAnchorOwnershipCall__Outputs {
  _call: TransferAnchorOwnershipCall;

  constructor(call: TransferAnchorOwnershipCall) {
    this._call = call;
  }
}

export class WithdrawETHCall extends ethereum.Call {
  get inputs(): WithdrawETHCall__Inputs {
    return new WithdrawETHCall__Inputs(this);
  }

  get outputs(): WithdrawETHCall__Outputs {
    return new WithdrawETHCall__Outputs(this);
  }
}

export class WithdrawETHCall__Inputs {
  _call: WithdrawETHCall;

  constructor(call: WithdrawETHCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class WithdrawETHCall__Outputs {
  _call: WithdrawETHCall;

  constructor(call: WithdrawETHCall) {
    this._call = call;
  }
}

export class AddReserveCall extends ethereum.Call {
  get inputs(): AddReserveCall__Inputs {
    return new AddReserveCall__Inputs(this);
  }

  get outputs(): AddReserveCall__Outputs {
    return new AddReserveCall__Outputs(this);
  }
}

export class AddReserveCall__Inputs {
  _call: AddReserveCall;

  constructor(call: AddReserveCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _weight(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class AddReserveCall__Outputs {
  _call: AddReserveCall;

  constructor(call: AddReserveCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall extends ethereum.Call {
  get inputs(): AcceptOwnershipCall__Inputs {
    return new AcceptOwnershipCall__Inputs(this);
  }

  get outputs(): AcceptOwnershipCall__Outputs {
    return new AcceptOwnershipCall__Outputs(this);
  }
}

export class AcceptOwnershipCall__Inputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall__Outputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AddLiquidityCall extends ethereum.Call {
  get inputs(): AddLiquidityCall__Inputs {
    return new AddLiquidityCall__Inputs(this);
  }

  get outputs(): AddLiquidityCall__Outputs {
    return new AddLiquidityCall__Outputs(this);
  }
}

export class AddLiquidityCall__Inputs {
  _call: AddLiquidityCall;

  constructor(call: AddLiquidityCall) {
    this._call = call;
  }

  get _reserveTokens(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get _reserveAmounts(): Array<BigInt> {
    return this._call.inputValues[1].value.toBigIntArray();
  }

  get _minReturn(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class AddLiquidityCall__Outputs {
  _call: AddLiquidityCall;

  constructor(call: AddLiquidityCall) {
    this._call = call;
  }
}

export class RemoveLiquidityCall extends ethereum.Call {
  get inputs(): RemoveLiquidityCall__Inputs {
    return new RemoveLiquidityCall__Inputs(this);
  }

  get outputs(): RemoveLiquidityCall__Outputs {
    return new RemoveLiquidityCall__Outputs(this);
  }
}

export class RemoveLiquidityCall__Inputs {
  _call: RemoveLiquidityCall;

  constructor(call: RemoveLiquidityCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _reserveTokens(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }

  get _reserveMinReturnAmounts(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }
}

export class RemoveLiquidityCall__Outputs {
  _call: RemoveLiquidityCall;

  constructor(call: RemoveLiquidityCall) {
    this._call = call;
  }
}

export class RestoreRegistryCall extends ethereum.Call {
  get inputs(): RestoreRegistryCall__Inputs {
    return new RestoreRegistryCall__Inputs(this);
  }

  get outputs(): RestoreRegistryCall__Outputs {
    return new RestoreRegistryCall__Outputs(this);
  }
}

export class RestoreRegistryCall__Inputs {
  _call: RestoreRegistryCall;

  constructor(call: RestoreRegistryCall) {
    this._call = call;
  }
}

export class RestoreRegistryCall__Outputs {
  _call: RestoreRegistryCall;

  constructor(call: RestoreRegistryCall) {
    this._call = call;
  }
}

export class FundCall extends ethereum.Call {
  get inputs(): FundCall__Inputs {
    return new FundCall__Inputs(this);
  }

  get outputs(): FundCall__Outputs {
    return new FundCall__Outputs(this);
  }
}

export class FundCall__Inputs {
  _call: FundCall;

  constructor(call: FundCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class FundCall__Outputs {
  _call: FundCall;

  constructor(call: FundCall) {
    this._call = call;
  }
}

export class AcceptAnchorOwnershipCall extends ethereum.Call {
  get inputs(): AcceptAnchorOwnershipCall__Inputs {
    return new AcceptAnchorOwnershipCall__Inputs(this);
  }

  get outputs(): AcceptAnchorOwnershipCall__Outputs {
    return new AcceptAnchorOwnershipCall__Outputs(this);
  }
}

export class AcceptAnchorOwnershipCall__Inputs {
  _call: AcceptAnchorOwnershipCall;

  constructor(call: AcceptAnchorOwnershipCall) {
    this._call = call;
  }
}

export class AcceptAnchorOwnershipCall__Outputs {
  _call: AcceptAnchorOwnershipCall;

  constructor(call: AcceptAnchorOwnershipCall) {
    this._call = call;
  }
}

export class UpgradeCall extends ethereum.Call {
  get inputs(): UpgradeCall__Inputs {
    return new UpgradeCall__Inputs(this);
  }

  get outputs(): UpgradeCall__Outputs {
    return new UpgradeCall__Outputs(this);
  }
}

export class UpgradeCall__Inputs {
  _call: UpgradeCall;

  constructor(call: UpgradeCall) {
    this._call = call;
  }
}

export class UpgradeCall__Outputs {
  _call: UpgradeCall;

  constructor(call: UpgradeCall) {
    this._call = call;
  }
}

export class ConvertCall extends ethereum.Call {
  get inputs(): ConvertCall__Inputs {
    return new ConvertCall__Inputs(this);
  }

  get outputs(): ConvertCall__Outputs {
    return new ConvertCall__Outputs(this);
  }
}

export class ConvertCall__Inputs {
  _call: ConvertCall;

  constructor(call: ConvertCall) {
    this._call = call;
  }

  get _sourceToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _targetToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _trader(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _beneficiary(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class ConvertCall__Outputs {
  _call: ConvertCall;

  constructor(call: ConvertCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SetConversionFeeCall extends ethereum.Call {
  get inputs(): SetConversionFeeCall__Inputs {
    return new SetConversionFeeCall__Inputs(this);
  }

  get outputs(): SetConversionFeeCall__Outputs {
    return new SetConversionFeeCall__Outputs(this);
  }
}

export class SetConversionFeeCall__Inputs {
  _call: SetConversionFeeCall;

  constructor(call: SetConversionFeeCall) {
    this._call = call;
  }

  get _conversionFee(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetConversionFeeCall__Outputs {
  _call: SetConversionFeeCall;

  constructor(call: SetConversionFeeCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get _newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _registry(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _maxConversionFee(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class DefaultCall extends ethereum.Call {
  get inputs(): DefaultCall__Inputs {
    return new DefaultCall__Inputs(this);
  }

  get outputs(): DefaultCall__Outputs {
    return new DefaultCall__Outputs(this);
  }
}

export class DefaultCall__Inputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class DefaultCall__Outputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}
